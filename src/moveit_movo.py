#!/usr/bin/env python
import sys
import copy
import rospy
import moveit_commander
import geometry_msgs.msg
from moveit_msgs.msg import RobotTrajectory
from ros_reality_bridge.msg import MoveitTarget
from std_msgs.msg import String
import time


class PlanHandler(object):
    def __init__(self):
        moveit_commander.roscpp_initialize(sys.argv)
        rospy.init_node('move_group_python_interface', anonymous=True)
        self.robot = moveit_commander.RobotCommander()
        self.group_right = moveit_commander.MoveGroupCommander('right_arm')
        self.group_left = moveit_commander.MoveGroupCommander('left_arm')
        self.group_right.set_pose_reference_frame('/base_link')
        self.group_left.set_pose_reference_frame('/base_link')
        print 'pose reference frame before:', self.group_right.get_pose_reference_frame()
        self.group_right.set_pose_reference_frame('/base_link')
        self.group_left.set_pose_reference_frame('/base_link')
        print 'pose reference frame after:', self.group_right.get_pose_reference_frame()
        print 'planning frame:', self.group_right.get_planning_frame()
        print 'planning frame:', self.group_left.get_planning_frame()
        self.print_initializer_msgs()
        self.left_arm_plan_publisher = rospy.Publisher('/movo_moveit/left_arm_plan', RobotTrajectory, queue_size=1)
        self.right_arm_plan_publisher = rospy.Publisher('/movo_moveit/right_arm_plan', RobotTrajectory, queue_size=1)
        rospy.Subscriber('/movocontrol/goal_pose_left', MoveitTarget, self.left_arm_pose_callback)
        rospy.Subscriber('/movocontrol/goal_pose_right', MoveitTarget, self.right_arm_pose_callback)

    def print_initializer_msgs(self):
        print "================ Robot Groups ==============="
        print self.robot.get_group_names()
        print "================ Robot State ================"
        print self.robot.get_current_state()
        print "============================================="

    def left_arm_pose_callback(self, data):
        pass

    def right_arm_pose_callback(self, data):
        pass

    def get_pose_right_arm(self):
        """
        Get the pose of the right end-effector.
        :return: geometry_msgs.msg.Pose
        """
        return self.group_right.get_current_pose().pose
        
    def get_pose_left_arm(self):
        """
        Get the pose of the left end-effector.
        :return: geometry_msgs.msg.Pose
        """
        return self.group_left.get_current_pose().pose
    
    def generate_plan_right_arm(self, goal_pose):
        """
        Moves the left end effector to the specified pose.
        :param goal_pose: A list of 7 floats: (x,y,z,qx,qy,qz,qw)
        :return: RobotTrajectory (None if failed)
        """
        plan = generate_plan(self.group_right, goal_pose)
        if plan is None:
            print 'plan failed :('
            return None
        self.right_arm_plan_publisher.publish(plan)
        return plan

    def generate_plan_left_arm(self, goal_pose):
        """
        Moves the left end effector to the specified pose.
        :param goal_pose: A list of 7 floats: (x,y,z,qx,qy,qz,qw)
        :return: RobotTrajectory (None if failed)
        """
        plan = generate_plan(self.group_left, goal_pose)
        if plan is None:
            return None
        self.left_arm_plan_publisher.publish(plan)
        return plan

    def execute_plan_right_arm(self, plan):
        """
        Executes the group_right plan movement, generated by plan_right_arm().
        :type plan: RobotTrajectory
        :return: Boolean indicating success.
        """
        return execute_plan(self.group_right, plan)

    def execute_plan_left_arm(self, plan):
        """
        Executes the group_left plan movement, generated by plan_left_arm().
        :type plan: RobotTrajectory
        :return: Boolean indicating success.
        """
        return execute_plan(self.group_left, plan)
        
    def generate_identity_plan(self, execute=False):
        """
        Generate a plan to move to the current pose - used to force joint state updates in unity.
        :return: moveit_msgs.msg.RobotTrajectory (None if failed)
        """
        pose = self.get_pose_left_arm()
        poselist = [pose.position.x, pose.position.y, pose.position.z, pose.orientation.x, pose.orientation.y,
                    pose.orientation.z, pose.orientation.w]
        print 'pose:', poselist
        plan = self.generate_plan_left_arm(poselist)
        if execute:
            self.execute_plan_left_arm(plan)
        return plan


def generate_plan(group, goal_pose):
    """
    Moves the group ('left_arm' or 'right_arm') to goal_pose
    :param goal_pose: A list of 7 floats: (x,y,z,qx,qy,qz,qw)
    :return: RobotTrajectory (None if failed)
    :type group: moveit_commander.move_group.MoveGroupCommander
    """
    assert isinstance(group, moveit_commander.move_group.MoveGroupCommander)
    pose_target = generate_pose_target(goal_pose)
    group.set_pose_target(pose_target)
    plan = group.plan()
    if not plan.joint_trajectory.joint_names:  # empty list means failed plan
        print 'Plan failed! :('
        return None
    print 'plan:', plan
    return plan


def execute_plan(group, plan):
    """
    Execute the group's plan.
    :type group: moveit_commander.move_group.MoveGroupCommander
    :type plan: RobotTrajectory
    :return: A boolean indicating success of movement execution.
    """
    if plan is None:
        print 'No plan to execute!'
        return False
    assert isinstance(group, moveit_commander.move_group.MoveGroupCommander)
    assert isinstance(plan, RobotTrajectory)
    return group.execute(plan)


def generate_pose_target(pose):
    """
    Takes in a pose and converts it to geometry_msgs.msg.Pose
    :param pose: A list of 7 floats: (x,y,z,qx,qy,qz,qw)
    """
    assert len(pose) == 7  # assert 3 positions and 4 quaternions
    assert all(isinstance(c, float) for c in pose)  # assert pose contains only floats
    pose_target = geometry_msgs.msg.Pose()
    pose_target.position.x = pose[0]
    pose_target.position.y = pose[1]
    pose_target.position.z = pose[2]
    pose_target.orientation.x = pose[3]
    pose_target.orientation.y = pose[4]
    pose_target.orientation.z = pose[5]
    pose_target.orientation.w = pose[6]
    return pose_target


def identity_pose_request_callback(data):
    planHandler.generate_identity_plan(execute=True)


if __name__ == '__main__':
    rospy.Subscriber('/holocontrol/identity_pose_request', String, identity_pose_request_callback)
    planHandler = PlanHandler()
    plan = planHandler.generate_identity_plan()
    while plan is None:
        plan = planHandler.generate_identity_plan()
    rospy.spin()
